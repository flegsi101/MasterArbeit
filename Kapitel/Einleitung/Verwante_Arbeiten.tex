\section{Verwandte Arbeiten}

\subsection{Change Data Capture (CDC)}

Unter Change Data Capture versteht man das Erfassen von Änderungen an Daten in Datenspeichern.
Dies wird gemacht um die erfassten Änderungen an andere Systeme weitergeben zu können, die die Änderungen dann weiter auswerten.
Dieses Vorgehen spielt mittlerweile in viele Bereichen eine Rolle und es gibt einige Arbeiten, die sich mit dem Thema und verschiedenen Vorgehen dazu befassen.
In den Arbeiten \citetitle{delta-view_gen}\parencite{delta-view_gen}, \citetitle{cdc_in_nosql}\parencite{cdc_in_nosql} und \citetitle{boeing}\parencite{boeing} werden vier Ansätze für die Umsetzung von CDC erläutert.

\subsubsection{Snapshot basiert}
Der erste Ansatz ist das Vergleichen von zwei Momentaufnahmen (Snapshots) eines Datensatzes.
Dabei wird bei jedem Durchlauf der CDC zuerst ein aktueller Snapshot generiert.
Danach wird dieser Snapshot mit dem Snapshot des vorherigen Durchlaufs verglichen, um alle Änderungen zu erhalten.
Hierfür muss ein separater Speicherort für diese Snapshots festgelegt werde.
Ein Nachteil dieser Methode ist, dass man nicht den gesamten Änderungsverlauf zwischen zwei Snapshots nachvollziehen kann.
Außerdem müssen den Vergleich immer alle Daten geladen werden, was zu einem hohen Rechen- und Speicheraufwand führen kann \cite{cdc_in_nosql}.

Zwei Ansätze eine Liste von Einfügungen, Änderungen und Löschungen aus zwei Snapshots zu erhalten, die auch von \citeauthor{cdc_in_nosql} \cite{cdc_in_nosql} referenziert werden, haben W. Labio und H. Garcia-Molina \cite{snapshot_algos} dargelegt.
Dazu werden alle Daten als Einträge mit einem einzigartigen Schlüssel und den dazu gehörigen Daten betrachtet.

Der erst genannte Ansatz basiert auf Join-Algorithmen, wie sie in der Informatik, zum Beispiel in \cite{joins}, schon viel besprochen wurden.
Wenn man die Einträge beider Snapshots über ihren Schlüssel verknüpft, kann man so durch einen Vergleich der Ergebnisse alle geänderten Einträge finden.
Um dann noch alle Einfügungen und Löschungen zu finden, kann man einen Outerjoin durchführen.
Bei einem Outerjoin erhält man alle Daten, die nur in einem der beiden Datensätze auftauchen.
Je nachdem in welchem Datensatz die Daten auftauchen, handelt es sich dann um eine Einfügung oder Löschung.

Als zweites wurde ein neuerer Algorithmus präsentiert, der mit der Annahme arbeitet, dass die Einträge in beiden Snapshots nah beieinander liegen.
Bei diesem Algorithmus wird ein Fenster von fester Länge über beide Snapshots geschoben und nur Einträge aus diesem Fenster verglichen.
Bei diesem Vorgehen reicht es aus, beide Snapshots nur einmal zu lesen.
Es kann aber je nach Aufteilung der Einträge passieren, dass sogenannte unnütze Einträge entstehen.
Diese werden definiert als eine Folge von Änderungen, die keine Auswirkung auf das Endergebnis hat.
Das sind Folgen, bei denen erst ein Eintrag gelöscht und dann eingefügt wird, oder andersherum.

\subsubsection{Zeitstempel basiert}
Ein weiterer Ansatz ist die Verwendung von Zeitstempeln.
Diese enthalten immer den Zeitpunkt der letzen Änderung.
Um Zeitstempel für die CDC zu verwenden werden, muss jedem Dateneintrag eine weitere Spalte (der Begriff Spalte bezieht sich hier nicht nur auf tabellen-artige Daten, sondern meint ein Feld, dass jeder Datensatz enthält) dafür hinzugefügt werden.
Auf diese Art kann man ebenfalls nur die kumulierten Änderungen seit dem letzten Durchlauf und keine Löschungen erfassen.

Ohne weiteren Aufwand ist es bei diesem Vorgehen auch nicht möglich zu unterscheiden, ob ein Datensatz sich geändert hat oder neu eingefügt wurde, da der Zeitstempel darüber keine Aussage treffen kann \cite{delta-view_gen}.
In \cite{cdc_in_nosql} wird als Lösung dafür vorgeschlagen, zwei Zeitstempel zu verwenden. Einer enthält den Zeitpunkt der Erstellung und der andere den der letzten Änderung. Diese werden dann mit dem Zeitpunkt des letzten CDC Durchlaufs verglichen. Wenn beide hinter dem letzten Durchlauf liegen, handelt es sich um eine Einfügung und wenn der erste vor und der zweite dahinter liegen um eine Aktualisierung.

Ein weiteres Problem kann sein, dass auch der Aufwand zum Finden der relevanten Zeitstempel bei vielen Daten hoch sein kann. Am Beispiel von SQL-Datenbanken bedeutet das, wenn es keinen Index auf die Zeitstempelspalten gibt, muss die gesamte Tabelle gelesen werden \cite{boeing}.

\subsubsection{Trigger basiert}
Trigger sind Programm-Codes, die vom Datenbanksystem bei verschiedenen Events ausgeführt werden.
Diese können verwendet werden, um alle Änderungen zu erfassen und für das CDC-Programm festzuhalten.
Die Grundvoraussetzung dafür ist, dass das System, auf dem die Daten verwaltet werden diese auch unterstützt.
Mit Hilfe der Trigger können alle Änderungen, auch die, die zwischen zwei CDC-Durchläufen passieren, erfasst werden.

\subsubsection{Log basiert}
Die letzte Möglichkeit ist, die Logfunktionen eines Systems zu nutzen.
Die meisten Datenbanksysteme zum Beispiel benutzen selbst Logs, um Wiederherstellungen möglich zu machen \cite{delta-view_gen}.
Diese können dann auch von dem CDC-Programm ausgelesen und verwendet werden.
Hierdurch gibt es fast keinen extra Aufwand für das eigentliche System.
Aber auch hier gilt, dass diese Art nur bei Systemen verwendet werden kann, die eine entsprechende Logfunktion bieten.
Ein weiterer Nachteil ist, dass für verschiedene Systeme herstellerspeziefische Implementierungen benötigt werden \cite{delta-view_gen}.

\subsubsection{Anwendbarkeit}

Im Hinblick auf diese Arbeit kann festgehalten werden, dass die meisten Methoden zur CDC direkt bei den Datenspeichern ausgeführt werden müssen, in denen die Daten geändert werden.
Nur das Vorgehen, bei denen zwei Momentaufnahmen von Daten verglichen werden kann ortsunabhänigig ausgeführt werden.
Daher ist dieses Vorgehen auch die bessere Wahl, wenn es darum geht Datenquellen unabhängig die Möglichkeit zu geben Änderungsdaten zu berechnen.
Da dieses Vorgehen aber weniger effizient ist, sollte eine Ingestion-Schnittstelle sowohl die Möglichkeit bieten diese Änderungsdaten im Data Lake System zu erzeugen als auch von externen CDC-System Daten einzuspielen.